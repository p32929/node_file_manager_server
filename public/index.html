<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple File Upload Server</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* General Styling */
    :root {
      --primary: #4361ee;
      --primary-light: #4895ef;
      --primary-dark: #3f37c9;
      --success: #4cc9f0;
      --warning: #f72585;
      --gray-light: #f8f9fa;
      --gray: #e9ecef;
      --gray-dark: #6c757d;
      --text: #212529;
    }
    
    body {
      font-family: 'Segoe UI', Roboto, -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--gray-light);
      margin: 0;
      padding: 0;
      color: var(--text);
      line-height: 1.6;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      border-radius: 0 0 15px 15px;
      margin-bottom: 30px;
    }

    h1, h2, h3 {
      margin: 0;
      font-weight: 600;
    }

    header h1 {
      font-size: 28px;
      margin-bottom: 5px;
    }

    header p {
      margin: 0;
      opacity: 0.9;
      font-size: 16px;
    }

    .card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      margin-bottom: 20px;
      overflow: hidden;
      position: relative;
    }

    .card-header {
      background: var(--gray);
      padding: 15px 20px;
      border-bottom: 1px solid rgba(0,0,0,0.05);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .card-header h2 {
      margin: 0;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .card-body {
      padding: 20px;
    }

    /* Explorer Styling */
    #explorer .breadcrumb {
      display: flex;
      padding: 10px 0;
      margin-bottom: 15px;
      list-style: none;
      background-color: rgba(0,0,0,0.02);
      border-radius: 5px;
      overflow-x: auto;
      white-space: nowrap;
      padding: 10px;
    }

    #explorer .breadcrumb-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }

    #explorer .breadcrumb-item + .breadcrumb-item::before {
      content: "/";
      padding: 0 8px;
      color: var(--gray-dark);
    }

    #explorer .breadcrumb-item a {
      color: var(--primary);
      text-decoration: none;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #explorer .breadcrumb-item a:hover {
      text-decoration: underline;
    }

    #explorer .breadcrumb-item.active {
      color: var(--gray-dark);
    }

    .folder-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }

    .folder {
      padding: 12px 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 14px;
      font-size: 15px;
      border: 1px solid var(--gray);
      background: rgba(255,255,255,0.5);
    }

    .folder:hover {
      background: var(--gray);
      transform: translateY(-2px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }

    .folder i {
      color: var(--primary);
      font-size: 18px;
    }

    .buttons {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    button {
      padding: 12px 18px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      background: var(--primary);
      color: white;
      border-radius: 8px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 500;
    }

    button:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: var(--gray);
      color: var(--gray-dark);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button:disabled:hover {
      background: var(--gray);
      transform: none;
      box-shadow: none;
    }

    button.secondary {
      background: var(--gray);
      color: var(--text);
    }

    button.secondary:hover {
      background: var(--gray-dark);
      color: white;
    }

    button.danger {
      background: var(--warning);
    }

    button.danger:hover {
      background: #d31367; /* Darker shade of warning */
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    #cancelButton {
      display: none;
    }

    /* Upload Form */
    #uploadForm {
      margin-top: 20px;
    }

    .file-input-container {
      position: relative;
      margin-bottom: 20px;
    }

    .file-input-container input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-input-button {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 30px;
      border: 2px dashed var(--gray-dark);
      border-radius: 8px;
      background: var(--gray-light);
      text-align: center;
      color: var(--gray-dark);
      transition: all 0.3s;
    }

    .file-input-container:hover .file-input-button {
      border-color: var(--primary);
      color: var(--primary);
      background: rgba(67, 97, 238, 0.05);
    }

    .file-info {
      margin-top: 12px;
      display: none;
      background: var(--gray-light);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* Progress Bar */
    .progress-container {
      margin-top: 15px;
      background-color: var(--gray);
      border-radius: 8px;
      overflow: hidden;
      height: 8px;
      display: none;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary), var(--success));
      border-radius: 8px;
      transition: width 0.3s;
    }

    /* Upload Info */
    .upload-info {
      margin-top: 12px;
      font-size: 14px;
      color: var(--gray-dark);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* Modal for How-To Guide */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.4);
      animation: fadeIn 0.3s;
      overflow: hidden;
      justify-content: center;
      align-items: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal-content {
      background-color: white;
      padding: 0;
      width: 90%;
      max-width: 700px;
      max-height: 75vh;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
      animation: slideIn 0.3s;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
      margin: 0;
    }

    @keyframes slideIn {
      from { transform: translateY(-30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal-header {
      padding: 15px 20px;
      background: var(--primary);
      color: white;
      border-radius: 12px 12px 0 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 20px;
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex-grow: 1;
    }

    .close {
      color: white;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      opacity: 0.7;
    }

    .guide-section {
      margin-bottom: 25px;
    }

    .guide-section h3 {
      display: flex;
      align-items: center;
      gap: 14px;
      font-size: 18px;
      margin-bottom: 12px;
      color: var(--primary-dark);
    }

    .guide-section p {
      margin: 0 0 10px 0;
      line-height: 1.6;
    }

    .guide-steps {
      padding-left: 30px;
    }

    .guide-steps li {
      margin-bottom: 8px;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 30px 20px;
      color: var(--gray-dark);
    }

    .empty-state i {
      font-size: 40px;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    /* Help button */
    .help-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.3s;
    }

    .help-button:hover {
      transform: scale(1.1);
    }

    /* Toast notification */
    #toast {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: #333;
      color: white;
      padding: 14px 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 14px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
      z-index: 1000;
      max-width: 90%;
    }

    #toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    #toast.success {
      background: #28a745;
    }

    #toast.error {
      background: #dc3545;
    }
    
    #toast.info {
      background: var(--primary);
    }
    
    #toastMessage {
      word-break: break-word;
      flex-grow: 1;
    }

    /* Enhanced toast for detailed errors */
    #errorDetails {
      display: none;
      padding: 10px;
      margin-top: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 100px;
      overflow-y: auto;
      font-size: 12px;
    }
    
    #toast.error #errorDetails.has-details {
      display: block;
    }
    
    #toast .toast-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    #toast .toast-actions button {
      padding: 5px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    #toast .toast-actions button:hover {
      background: rgba(255,255,255,0.3);
    }
    
    #toast.error.detailed {
      width: 500px;
      max-width: 90%;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .folder-list {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }

      .modal-content {
        width: 95%;
        max-height: 80vh;
      }
      
      .modal-body {
        padding: 15px;
      }
      
      .guide-section h3 {
        font-size: 16px;
      }
      
      .guide-steps {
        padding-left: 20px;
      }

      .buttons {
        flex-direction: column;
        width: 100%;
      }

      button {
        width: 100%;
      }
      
      .button-group {
        flex-direction: column;
      }
      
      #toast {
        left: 50%;
        transform: translateY(100px) translateX(-50%);
        width: 90%;
      }
      
      #toast.show {
        transform: translateY(0) translateX(-50%);
      }
    }

    .file-path {
      word-break: break-all;
      display: inline-block;
      font-family: monospace;
      background: rgba(0,0,0,0.05);
      padding: 2px 5px;
      border-radius: 3px;
      margin-top: 5px;
    }
    
    .toast {
      max-width: 80%;
      word-break: break-word;
    }
    
    .toast.success {
      max-width: 100%;
    }
  </style>
</head>
<body>
  <header>
    <h1><i class="fas fa-cloud-upload-alt"></i> Simple File Upload Server</h1>
    <p>Upload files to any folder on your server with ease</p>
  </header>

  <div class="container">
    <div class="card" id="explorer">
      <div class="card-header">
        <h2><i class="fas fa-folder"></i> File Explorer</h2>
        <button class="secondary" onclick="showHowTo()"><i class="fas fa-question-circle"></i> Help</button>
      </div>
      <div class="card-body">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb" id="breadcrumb">
            <li class="breadcrumb-item active"><i class="fas fa-home"></i> Root</li>
          </ol>
        </nav>
        
        <div id="folders" class="folder-list">Loading folders...</div>
        
    <div class="buttons">
          <button onclick="goBack()"><i class="fas fa-arrow-left"></i> Back</button>
      <button onclick="goUp()"><i class="fas fa-arrow-up"></i> Go Up</button>
          <button onclick="selectFolder()"><i class="fas fa-check-circle"></i> Select This Folder</button>
        </div>
    </div>
  </div>

    <div class="card" id="uploadForm" style="display: none;">
      <div class="card-header">
    <h2><i class="fas fa-upload"></i> Upload File</h2>
        <div id="selectedPath">No folder selected</div>
      </div>
      <div class="card-body">
        <div class="file-input-container">
          <div class="file-input-button">
            <i class="fas fa-file-upload fa-2x"></i>
            <div>
              <p>Drop your file here or click to browse</p>
              <p style="font-size: 12px; margin-top: 5px; opacity: 0.7;">Drag and drop files or click to select</p>
            </div>
          </div>
          <input type="file" id="fileInput" onchange="updateFileInfo()">
        </div>

        <div class="file-info" id="fileInfo">
          <i class="fas fa-file"></i> <span id="fileName"></span> (<span id="fileSize"></span>)
        </div>

    <input type="hidden" name="targetPath" id="targetPath">
        <div class="button-group">
          <button type="button" id="uploadButton" onclick="uploadFile()"><i class="fas fa-cloud-upload-alt"></i> Upload File</button>
          <button type="button" id="cancelButton" class="danger" onclick="cancelUpload()"><i class="fas fa-times-circle"></i> Cancel Upload</button>
        </div>

    <div class="progress-container">
      <div class="progress-bar"></div>
    </div>

    <div class="upload-info" id="uploadInfo"></div>
      </div>
    </div>
  </div>

  <!-- How-To Guide Modal -->
  <div id="howToModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2><i class="fas fa-book"></i> How to Use the File Server</h2>
        <span class="close" onclick="closeHowTo()">&times;</span>
      </div>
      <div class="modal-body">
        <div class="guide-section">
          <h3><i class="fas fa-compass"></i> Navigation</h3>
          <p>Navigate through folders to find the right location for your file:</p>
          <ol class="guide-steps">
            <li>Use the <strong>File Explorer</strong> to browse through folders</li>
            <li>Click on any folder to navigate into it</li>
            <li>Use the <strong>Back</strong> button to return to the previous folder</li>
            <li>Use the <strong>Go Up</strong> button to navigate to the parent folder</li>
            <li>The path display at the top shows your current location</li>
          </ol>
        </div>

        <div class="guide-section">
          <h3><i class="fas fa-upload"></i> Uploading Files</h3>
          <p>Upload your files in just a few steps:</p>
          <ol class="guide-steps">
            <li>Navigate to the folder where you want to upload your file</li>
            <li>Click <strong>Select This Folder</strong> to target this location</li>
            <li>The upload form will appear below</li>
            <li>Click on the upload area or drag & drop your file</li>
            <li>Click the <strong>Upload File</strong> button to start the upload</li>
            <li>You'll see a progress bar showing upload status</li>
          </ol>
        </div>

        <div class="guide-section">
          <h3><i class="fas fa-tachometer-alt"></i> Progress Tracking</h3>
          <p>Track your upload progress in real-time:</p>
          <ul class="guide-steps">
            <li>The progress bar shows the percentage of completion</li>
            <li>You'll see the upload speed (KB/s, MB/s)</li>
            <li>Remaining file size and time estimate is displayed</li>
            <li>A notification will appear when the upload completes</li>
          </ul>
        </div>

        <div class="guide-section">
          <h3><i class="fas fa-lightbulb"></i> Tips</h3>
          <ul class="guide-steps">
            <li>You can access this guide anytime by clicking the Help button</li>
            <li>For large files, keep the browser window open until upload completes</li>
            <li>The breadcrumb navigation allows quick jumps between folders</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Button -->
  <div class="help-button" onclick="showHowTo()">
    <i class="fas fa-question"></i>
  </div>

  <!-- Toast Notification -->
  <div id="toast">
    <i class="fas fa-check-circle"></i>
    <div>
      <span id="toastMessage"></span>
      <div id="errorDetails"></div>
      <div class="toast-actions" id="toastActions"></div>
    </div>
  </div>

  <script>
    let currentPath = '/';
    // Track navigation history for back button
    let navigationHistory = [];

    function fetchFolders(dirPath = '/', addToHistory = true) {
      document.getElementById('folders').innerHTML = '<div class="empty-state"><i class="fas fa-spinner fa-spin"></i><p>Loading folders...</p></div>';

      // Add current path to history before navigating to new path
      if (addToHistory && currentPath !== dirPath) {
        navigationHistory.push(currentPath);
      }

      fetch(`/list-folders?path=${encodeURIComponent(dirPath)}`)
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            document.getElementById('folders').innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error: ${data.error}</p></div>`;
            return;
          }

          currentPath = data.path;
          
          // If we're at the Windows root, fetch and display drives
          if (data.isRoot) {
            fetchDrives();
            return;
          }
          
          updateBreadcrumb(currentPath);
          const foldersDiv = document.getElementById('folders');
          foldersDiv.innerHTML = '';

          if (data.folders.length === 0) {
            foldersDiv.innerHTML = `<div class="empty-state"><i class="fas fa-folder-open"></i><p>No subfolders found</p><small>This folder is empty</small></div>`;
          } else {
            data.folders.forEach(name => {
              const div = document.createElement('div');
              div.className = 'folder';
              div.innerHTML = `<i class="fas fa-folder"></i> <span>${name}</span>`;
              div.onclick = () => fetchFolders(`${currentPath === '/' ? '' : currentPath}/${name}`);
              foldersDiv.appendChild(div);
            });
          }
        })
        .catch(err => {
          document.getElementById('folders').innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-circle"></i><p>Failed to load folders</p><small>Please try again</small></div>`;
        });
    }
    
    function fetchDrives() {
      fetch('/list-drives')
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            document.getElementById('folders').innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error: ${data.error}</p></div>`;
            return;
          }
          
          currentPath = '/';
          updateBreadcrumb(currentPath, true);
          
          const foldersDiv = document.getElementById('folders');
          foldersDiv.innerHTML = '';
          
          if (data.drives && data.drives.length > 0) {
            data.drives.forEach(drive => {
              const div = document.createElement('div');
              div.className = 'folder';
              div.innerHTML = `<i class="fas fa-hdd"></i> <span>${drive}</span>`;
              div.onclick = () => fetchFolders(drive);
              foldersDiv.appendChild(div);
            });
          } else {
            foldersDiv.innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-circle"></i><p>No drives found</p></div>`;
          }
        })
        .catch(err => {
          document.getElementById('folders').innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-circle"></i><p>Failed to load drives</p><small>Please try again</small></div>`;
        });
    }

    function updateBreadcrumb(path, isRoot = false) {
      const breadcrumb = document.getElementById('breadcrumb');
      breadcrumb.innerHTML = ''; // Clear all breadcrumbs
      
      let displayPath;
      
      if (isRoot) {
        // For Windows root (My Computer)
        const li = document.createElement('li');
        li.className = 'breadcrumb-item active';
        li.innerHTML = '<i class="fas fa-desktop"></i> My Computer';
        breadcrumb.appendChild(li);
        return;
      }
      
      // Handle drive paths or regular paths
      if (path.match(/^[A-Z]:\\/i)) {
        // Windows drive path
        displayPath = path;
      } else {
        // Unix-style path
        displayPath = path === '/' ? 'Root' : path;
      }
      
      const li = document.createElement('li');
      li.className = 'breadcrumb-item active';
      li.innerHTML = path === '/' ? '<i class="fas fa-home"></i> Root' : displayPath;
      breadcrumb.appendChild(li);
    }

    function goBack() {
      if (navigationHistory.length === 0) {
        showToast('No previous folder to go back to', 'info');
        return;
      }
      
      const previousPath = navigationHistory.pop();
      fetchFolders(previousPath, false); // Don't add to history when going back
    }

    function goUp() {
      if (currentPath === '/') {
        // Already at root, do nothing or show a message
        showToast('Already at the root level', 'info');
        return;
      }
      
      const parts = currentPath.split(/[\/\\]/).filter(part => part);
      
      // Handle Windows drive paths (C:\)
      if (parts.length === 1 && parts[0].endsWith(':')) {
        fetchFolders('/'); // Go to drives list
        return;
      }
      
      parts.pop();
      
      // If we've gone up to a drive root (like C:\)
      if (parts.length === 1 && parts[0].endsWith(':')) {
        fetchFolders(parts[0] + '\\');
        return;
      }
      
      fetchFolders('/' + parts.join('/'));
    }

    function selectFolder() {
      document.getElementById('targetPath').value = currentPath;
      document.getElementById('selectedPath').textContent = `Selected: ${currentPath}`;
      document.getElementById('uploadForm').style.display = 'block';
      
      // Scroll to the upload form
      document.getElementById('uploadForm').scrollIntoView({ behavior: 'smooth' });
      
      showToast('Folder selected! You can now upload files.', 'success');
    }

    function updateFileInfo() {
      const file = document.getElementById('fileInput').files[0];
      if (file) {
        document.getElementById('fileInfo').style.display = 'block';
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileSize').textContent = formatSize(file.size);
        
        // Change icon based on file type
        const fileIcon = document.querySelector('#fileInfo i');
        const fileExtension = file.name.split('.').pop().toLowerCase();
        
        if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-image';
        } else if (['pdf'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-pdf';
        } else if (['doc', 'docx'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-word';
        } else if (['xls', 'xlsx', 'csv'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-excel';
        } else if (['zip', 'rar', '7z', 'tar', 'gz'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-archive';
        } else if (['mp4', 'avi', 'mov', 'wmv'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-video';
        } else if (['mp3', 'wav', 'ogg'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-audio';
        } else if (['html', 'css', 'js', 'php', 'py', 'java', 'c', 'cpp'].includes(fileExtension)) {
          fileIcon.className = 'fas fa-file-code';
        } else {
          fileIcon.className = 'fas fa-file';
        }
      }
    }

    // Global variables for uploads
    let isUploading = false;
    let chunkUploadAborted = false;
    let isThrottled = false;
    let lastChunkBytes = 0;
    let uploadSpeeds = [];
    const SPEED_WINDOW_SIZE = 10; // Increase speed sampling window for smoother average
    let lastProgressTime = 0;
    let retryCount = 0;
    let retryDelay = 1000;
    const MAX_RETRY_COUNT = 5;
    const MAX_RETRY_DELAY = 16000; // 16 seconds max delay
    let currentChunk = 0; // Current chunk being uploaded
    let totalChunks = 0; // Total number of chunks for current upload
    let lastVisibilityNotification = 0; // Track when last notification was shown
    let lastUIUpdate = 0; // Track when last UI update was made
    let optimalChunkSize = 5 * 1024 * 1024; // Dynamic - will be adjusted
    let uploadedFileId = null; // Store the fileId from the server
    let uploadedBytes = 0; // Track total bytes uploaded
    let uploadStartTime = 0; // Track when upload started
    let overallStartTime = 0; // Track overall start time for better ETA calculation
    let speedSamples = []; // Track speed samples for trend analysis
    let lastSpeedAdjustmentTime = 0; // Track when we last adjusted chunk size
    let adaptiveAdjustmentEnabled = true; // Flag to enable/disable adaptive adjustments
    let networkCondition = 'unknown'; // Tracks network condition
    let uploadPerformance = []; // Tracks upload performance metrics
    let systemMemory = null; // Will store detected system memory if available
    let connectionType = null; // Will store connection type if available
    let chunkSizeHistory = []; // Track chunk size changes
    let adaptationFrequency = 3; // Check for adaptation every N chunks

    // Try to detect system capabilities
    function detectSystemCapabilities() {
      // Detect connection type if supported
      if (navigator.connection) {
        connectionType = navigator.connection.effectiveType || 
                         navigator.connection.type || 'unknown';
        
        // Listen for connection changes if supported
        if (navigator.connection.addEventListener) {
          navigator.connection.addEventListener('change', function() {
            // Update connection type when it changes
            connectionType = navigator.connection.effectiveType || 
                            navigator.connection.type || 'unknown';
            console.log(`Connection type changed to: ${connectionType}`);
            
            // Adjust strategy for next chunk if we're uploading
            if (isUploading) {
              // Force adjustment on next chunk
              lastSpeedAdjustmentTime = 0;
            }
          });
        }
        
        console.log(`Detected connection type: ${connectionType}`);
      }
      
      // Determine available memory if possible
      if (navigator.deviceMemory) {
        systemMemory = navigator.deviceMemory;
        console.log(`Detected device memory: ${systemMemory}GB`);
      }
      
      // Measure available memory in a different way
      if (performance && performance.memory) {
        const memInfo = performance.memory;
        console.log(`Memory limit: ${formatSize(memInfo.jsHeapSizeLimit)}`);
      }
      
      // Run initial speed test to determine network speed
      runSpeedTest()
        .then(speed => {
          console.log(`Initial speed test: ${formatSize(speed)}/s`);
          // Save as first speed sample
          speedSamples.push(speed);
          
          // Categorize network condition
          if (speed > 10 * 1024 * 1024) { // > 10 MB/s
            networkCondition = 'excellent';
          } else if (speed > 5 * 1024 * 1024) { // > 5 MB/s
            networkCondition = 'good';
          } else if (speed > 1 * 1024 * 1024) { // > 1 MB/s
            networkCondition = 'average';
          } else {
            networkCondition = 'slow';
          }
        })
        .catch(err => {
          console.warn('Speed test failed:', err);
        });
    }
    
    // Run a quick speed test by downloading a small file
    async function runSpeedTest() {
      return new Promise((resolve, reject) => {
        const testSize = 256 * 1024; // 256KB
        const testUrl = `/speed-test?size=${testSize}&t=${Date.now()}`;
        const startTime = Date.now();
        
        fetch(testUrl)
          .then(response => response.blob())
          .then(blob => {
            const endTime = Date.now();
            const duration = (endTime - startTime) / 1000; // seconds
            
            if (duration > 0) {
              const speed = testSize / duration;
              resolve(speed);
            } else {
              resolve(10 * 1024 * 1024); // Assume 10 MB/s if test was too fast
            }
          })
          .catch(err => {
            reject(err);
          });
      });
    }
    
    // Run capability detection on page load
    detectSystemCapabilities();
    
    // Track visibility changes
    document.addEventListener('visibilitychange', function() {
      if (isUploading) {
        isThrottled = document.hidden;
        // Remove the notification message completely
      }
    });

    function uploadFile() {
      const file = document.getElementById('fileInput').files[0];
      if (!file) {
        showToast('Please select a file first!', 'error');
        return;
      }

      // Adaptive initial chunk size
      optimalChunkSize = determineInitialChunkSize(file.size);
      
      // Reset state
      currentChunk = 0;
      totalChunks = Math.ceil(file.size / optimalChunkSize);
      chunkUploadAborted = false;
      isUploading = true;
      isThrottled = document.hidden; // Start throttled if in background
      lastProgressTime = Date.now(); // Initialize with current time
      lastChunkBytes = 0;
      retryCount = 0;
      retryDelay = 1000;
      uploadSpeeds = [];
      uploadStartTime = Date.now();
      overallStartTime = Date.now();
      uploadedBytes = 0;
      uploadedFileId = null;
      speedSamples = [];
      lastSpeedAdjustmentTime = 0;
      chunkSizeHistory = [];
      adaptiveAdjustmentEnabled = true;
      
      // Record initial chunk size decision
      chunkSizeHistory.push({
        chunkIndex: 0,
        size: optimalChunkSize,
        reason: 'initial',
        timestamp: Date.now()
      });
      
      // Show upload in progress
      updateUploadButtonState(true);
      
      // Initialize progress display
      document.querySelector('.progress-container').style.display = 'block';
      document.querySelector('.progress-bar').style.width = '0%';
      document.getElementById('uploadInfo').innerHTML = 
        `<i class="fas fa-info-circle"></i> Starting upload of ${formatSize(file.size)}...`;
      
      // Start the upload immediately without delay
      uploadChunk(file);
    }

    // Determine the best initial chunk size based on all available information
    function determineInitialChunkSize(fileSize) {
      // Start with connection type
      let baseChunkSize;
      
      // If we have connection information, use it
      if (connectionType) {
        switch(connectionType) {
          case '4g':
          case 'wifi':
            baseChunkSize = 8 * 1024 * 1024; // 8MB for fast connections
            break;
          case '3g':
            baseChunkSize = 3 * 1024 * 1024; // 3MB for 3G
            break;
          case '2g':
          case 'slow-2g':
            baseChunkSize = 512 * 1024; // 512KB for slow connections
            break;
          default:
            // Use file size based estimate if connection type is unknown
            baseChunkSize = estimateChunkSizeFromFileSize(fileSize);
        }
      } else {
        // Use file size based estimate if connection info not available
        baseChunkSize = estimateChunkSizeFromFileSize(fileSize);
      }
      
      // If we have speed samples from previous uploads or tests, use that data
      if (speedSamples.length > 0) {
        // Calculate average speed from samples
        const avgSpeed = speedSamples.reduce((a, b) => a + b, 0) / speedSamples.length;
        
        // Target 4-second upload time per chunk for smooth progress updates
        const targetTime = 4; // seconds
        const speedBasedSize = avgSpeed * targetTime;
        
        // Blend the two estimates with a bias toward speed-based sizing
        baseChunkSize = (baseChunkSize * 0.3) + (speedBasedSize * 0.7);
      }
      
      // Adjust for file size - larger files can use larger chunks
      // but very small files should use smaller chunks
      if (fileSize < 1024 * 1024) { // Less than 1MB
        baseChunkSize = Math.min(baseChunkSize, 256 * 1024); // Max 256KB
      } else if (fileSize > 1024 * 1024 * 1024) { // Greater than 1GB
        // For very large files, use larger chunks to reduce HTTP overhead
        baseChunkSize = Math.max(baseChunkSize, 8 * 1024 * 1024); // Min 8MB
      }
      
      // Apply system memory constraints if detected
      if (systemMemory) {
        // Limit chunk size based on device memory to prevent OOM
        const memoryLimit = Math.min(16, Math.max(1, systemMemory)) * 1024 * 1024;
        baseChunkSize = Math.min(baseChunkSize, memoryLimit);
      }
      
      // Enforce reasonable limits
      const minChunkSize = 256 * 1024; // 256KB minimum
      const maxChunkSize = 20 * 1024 * 1024; // 20MB maximum
      
      const finalChunkSize = Math.max(minChunkSize, Math.min(maxChunkSize, baseChunkSize));
      
      console.log(`Adaptive chunk size for ${formatSize(fileSize)} file: ${formatSize(finalChunkSize)}`);
      return finalChunkSize;
    }
    
    // Estimate chunk size based on file size
    function estimateChunkSizeFromFileSize(fileSize) {
      if (fileSize < 1 * 1024 * 1024) { // Less than 1MB
        return 256 * 1024; // 256KB
      } else if (fileSize < 10 * 1024 * 1024) { // Less than 10MB
        return 1 * 1024 * 1024; // 1MB
      } else if (fileSize < 100 * 1024 * 1024) { // Less than 100MB
        return 4 * 1024 * 1024; // 4MB
      } else if (fileSize < 1024 * 1024 * 1024) { // Less than 1GB
        return 8 * 1024 * 1024; // 8MB
      } else { // Larger than 1GB
        return 10 * 1024 * 1024; // 10MB
      }
    }
    
    // Track upload performance for a chunk
    function trackChunkPerformance(chunkIndex, chunkSize, startTime, endTime, success) {
      const duration = (endTime - startTime) / 1000; // seconds
      const speed = chunkSize / duration;
      
      // Add to performance history
      uploadPerformance.push({
        chunkIndex,
        chunkSize,
        duration,
        speed,
        success,
        timestamp: endTime
      });
      
      // Add to speed samples for moving averages
      if (success && speed > 0) {
        speedSamples.push(speed);
      }
      
      // Return performance data
      return {
        duration,
        speed,
        success
      };
    }
    
    // Adaptively determine optimal chunk size based on real-time performance
    function adaptChunkSize(file, currentPerformance) {
      if (!adaptiveAdjustmentEnabled || uploadPerformance.length < 2) {
        return optimalChunkSize;
      }
      
      // Only adapt every few chunks or if there's a significant change
      const shouldCheckForAdaptation = 
        currentChunk % adaptationFrequency === 0 || 
        Date.now() - lastSpeedAdjustmentTime > 10000;
        
      if (!shouldCheckForAdaptation) {
        return optimalChunkSize;
      }
      
      // Analyze recent performance
      const recentPerf = uploadPerformance.slice(-3);
      const olderPerf = uploadPerformance.slice(-6, -3);
      
      // If we don't have enough data, skip adaptation
      if (recentPerf.length < 2 || olderPerf.length < 2) {
        return optimalChunkSize;
      }
      
      // Calculate average speeds
      const recentAvgSpeed = recentPerf
        .filter(p => p.success)
        .reduce((sum, p) => sum + p.speed, 0) / recentPerf.length;
        
      const olderAvgSpeed = olderPerf
        .filter(p => p.success)
        .reduce((sum, p) => sum + p.speed, 0) / olderPerf.length;
      
      // Calculate upload durations
      const recentAvgDuration = recentPerf
        .filter(p => p.success)
        .reduce((sum, p) => sum + p.duration, 0) / recentPerf.length;
      
      // Check network stability by comparing speeds
      const speedRatio = recentAvgSpeed / olderAvgSpeed;
      const isSpeedDecreasing = speedRatio < 0.8; // 20% or more decrease
      const isSpeedIncreasing = speedRatio > 1.2; // 20% or more increase
      
      // Determine optimal upload time - aim for 2-6 seconds per chunk
      const targetUploadTime = 4; // seconds
      const optimalSize = recentAvgSpeed * targetUploadTime;
      
      // Set adaptation reason for logging
      let adaptationReason = '';
      
      // Current chunk size
      const currentSize = optimalChunkSize;
      let newChunkSize = currentSize;
      
      // Adapt chunk size based on conditions
      if (isSpeedDecreasing) {
        // Speed is decreasing - reduce chunk size
        newChunkSize = Math.max(256 * 1024, currentSize * 0.75);
        adaptationReason = 'decreasing_speed';
      } else if (isSpeedIncreasing && recentAvgDuration < 2) {
        // Speed is increasing and chunks upload too quickly
        // Increase chunk size for efficiency
        newChunkSize = Math.min(20 * 1024 * 1024, currentSize * 1.5);
        adaptationReason = 'increasing_speed';
      } else if (recentAvgDuration > 8) {
        // Uploads taking too long - reduce chunk size for better feedback
        newChunkSize = Math.max(256 * 1024, currentSize * 0.6);
        adaptationReason = 'duration_too_long';
      } else if (Math.abs(optimalSize - currentSize) / currentSize > 0.3) {
        // Current size is off by more than 30% from optimal
        newChunkSize = optimalSize;
        adaptationReason = 'optimizing';
      } else {
        // Current size is reasonable - no change needed
        return currentSize;
      }
      
      // If size would change by less than 20%, don't bother changing
      if (Math.abs(newChunkSize - currentSize) / currentSize < 0.2) {
        return currentSize;
      }
      
      // Apply constraints
      newChunkSize = Math.max(256 * 1024, Math.min(20 * 1024 * 1024, newChunkSize));
      
      // Round to nearest 256KB for cleaner sizes
      newChunkSize = Math.round(newChunkSize / (256 * 1024)) * (256 * 1024);
      
      // If we made a change, update last adjustment time
      if (newChunkSize !== currentSize) {
        console.log(`Adaptive chunk size adjustment: ${formatSize(currentSize)} â†’ ${formatSize(newChunkSize)} (${adaptationReason})`);
        lastSpeedAdjustmentTime = Date.now();
        
        // Record the change
        chunkSizeHistory.push({
          chunkIndex: currentChunk + 1,
          size: newChunkSize,
          reason: adaptationReason,
          timestamp: Date.now()
        });
        
        // If we changed chunk size, recalculate total chunks
        const remainingBytes = file.size - ((currentChunk + 1) * currentSize);
        const additionalChunks = Math.ceil(remainingBytes / newChunkSize);
        totalChunks = currentChunk + 1 + additionalChunks;
      }
      
      return newChunkSize;
    }

    function updateUploadButtonState(isDisabled) {
      document.getElementById('uploadButton').disabled = isDisabled;
      if (isDisabled) {
        document.getElementById('cancelButton').style.display = 'inline-block';
      } else {
        document.getElementById('cancelButton').style.display = 'none';
      }
    }
    
    function uploadChunk(file, fileId = null) {
      if (chunkUploadAborted) {
        isUploading = false;
        updateProgress();
        return;
      }

      if (currentChunk >= totalChunks) {
        showToast('Upload complete!', 'success');
        isUploading = false;
        updateProgress();
        const urlParams = new URLSearchParams(window.location.search);
        loadFileList(urlParams.get('path') || '');
        return;
      }
      
      // Define sendNextChunk function to handle progression through the upload
      function sendNextChunk() {
        // Increment the chunk counter for the next chunk
        currentChunk++;
        
        // Adapt chunk size for next chunk if enabled
        if (adaptiveAdjustmentEnabled && currentChunk < totalChunks) {
          optimalChunkSize = adaptChunkSize(file, uploadPerformance[uploadPerformance.length - 1]);
        }
        
        // Call uploadChunk again with the same file and fileId
        uploadChunk(file, uploadedFileId || fileId);
      }

      // Prepare chunk
      const start = currentChunk === 0 ? 0 : 
        uploadPerformance.reduce((sum, p, index) => 
          index < currentChunk ? sum + p.chunkSize : sum, 0);
      
      const end = Math.min(file.size, start + optimalChunkSize);
      const chunk = file.slice(start, end);
      const chunkSize = end - start;

      // Update progress immediately to show we're starting this chunk
      document.getElementById('uploadInfo').innerHTML = 
        `<i class="fas fa-upload"></i> Uploading chunk ${currentChunk + 1}/${totalChunks} (${formatSize(chunkSize)})...`;

      // Record the start time for this chunk
      const chunkStartTime = Date.now();

      // Create FormData
      const formData = new FormData();
      const tempFileName = file.name + '.' + Date.now();
      formData.append('file', chunk, tempFileName);

      // Prepare upload
      const xhr = new XMLHttpRequest();
      xhr.open('POST', '/upload-chunk', true);
      
      // Set headers for chunked upload
      xhr.setRequestHeader('X-File-Name', encodeURIComponent(file.name));
      xhr.setRequestHeader('X-Chunk-Index', currentChunk);
      xhr.setRequestHeader('X-Total-Chunks', totalChunks);
      
      // Include adaptive information for server optimization
      xhr.setRequestHeader('X-Client-Speed', speedSamples.length ? 
        Math.round(speedSamples.slice(-3).reduce((a,b) => a+b, 0) / 
        Math.min(3, speedSamples.length)) : 0);
      xhr.setRequestHeader('X-Chunk-Size', chunkSize);
      
      // If it's not the first chunk, use the fileId
      if (fileId) {
        xhr.setRequestHeader('X-File-Id', fileId);
      }

      // Store the current chunk we're working on for potential resume
      const chunkIndex = currentChunk;
      
      // Set a longer timeout for large chunks
      xhr.timeout = 60000; // 60 seconds timeout
      
      // Track upload progress per chunk
      xhr.upload.onprogress = function(e) {
        if (e.lengthComputable) {
          // Calculate chunk progress (0-1)
          const chunkProgress = e.loaded / e.total;
          
          // Calculate overall progress based on current performance
          let totalBytesUploaded = 0;
          
          // Add bytes from completed chunks
          if (uploadPerformance.length > 0) {
            totalBytesUploaded = uploadPerformance.reduce((sum, p) => sum + p.chunkSize, 0);
          }
          
          // Add bytes from current chunk in progress
          const currentChunkBytes = chunkProgress * chunkSize;
          totalBytesUploaded += currentChunkBytes;
          
          // Update upload speeds data
          const now = Date.now();
          if (lastProgressTime) {
            const timeElapsed = (now - lastProgressTime) / 1000; // seconds
            if (timeElapsed > 0.1) { // Only update if enough time has passed
              // Calculate this interval's speed
              const bytesUploaded = currentChunkBytes - lastChunkBytes;
              const speed = bytesUploaded / timeElapsed; // bytes per second
              
              // Ignore unrealistic speeds
              if (speed > 0 && speed < 500 * 1024 * 1024) { // Under 500 MB/s is realistic
                // Add to rolling window
                uploadSpeeds.push(speed);
                
                // Keep only the most recent samples
                if (uploadSpeeds.length > SPEED_WINDOW_SIZE) {
                  uploadSpeeds.shift();
                }
              }
            }
          }
          
          lastProgressTime = now;
          lastChunkBytes = currentChunkBytes;
          
          // Update the progress bar
          updateProgress(totalBytesUploaded, file.size);
        }
      };

      xhr.onload = function() {
        // Record end time for performance tracking
        const chunkEndTime = Date.now();
        
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            
            if (!response.success) {
              // Server returned an error with 200 status code but success=false
              const errorDetails = {
                code: response.error?.code || 'SERVER_ERROR',
                details: response.error?.message || response.error || 'Unknown server error',
                timestamp: new Date().toISOString(),
                chunkIndex: chunkIndex
              };
              console.error('Server returned error:', errorDetails);
              
              // Track failed performance
              trackChunkPerformance(chunkIndex, chunkSize, chunkStartTime, chunkEndTime, false);
              
              handleUploadError(xhr, file, fileId, response.error?.message || 'Server error', errorDetails);
              return;
            }
            
            // Store the fileId from the first chunk response
            if (chunkIndex === 0) {
              uploadedFileId = response.fileId;
              console.log(`Got fileId from server: ${uploadedFileId}`);
            }
            
            // Track successful performance
            const perfData = trackChunkPerformance(chunkIndex, chunkSize, chunkStartTime, chunkEndTime, true);
            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} uploaded at ${formatSize(perfData.speed)}/s`);
            
            // Mark this chunk as complete
            uploadedBytes += chunkSize;
            
            // Check if we're done with all chunks
            if (currentChunk >= totalChunks - 1) {
              // We're done!
              // Check if there's a filePath in the response and show it
              if (response.filePath) {
                console.log('File saved at:', response.filePath);
                showToast(`Upload complete! File saved at: ${response.filePath}`, 'success', 10000);
        } else {
                showToast('Upload complete!', 'success');
              }
              
              isUploading = false;
              
              // Update the UI
              document.querySelector('.progress-bar').style.width = '100%';
              document.getElementById('uploadInfo').innerHTML = 
                `<i class="fas fa-check-circle"></i> Upload complete! ${formatSize(file.size)} uploaded successfully.`;
              
              if (response.filePath) {
                document.getElementById('uploadInfo').innerHTML += 
                  `<br><i class="fas fa-save"></i> Saved at: <span class="file-path">${response.filePath}</span>`;
              }
              
              // Reenable the upload button
              updateUploadButtonState(false);
              
              return;
            }
            
            // Move to the next chunk
            sendNextChunk();
            
          } catch (e) {
            console.error('Error parsing server response:', e, xhr.responseText);
            const errorDetails = {
              code: 'INVALID_SERVER_RESPONSE',
              details: `Failed to parse server response: ${e.message}`,
              rawResponse: xhr.responseText.substring(0, 500), // Only include part of the response to avoid massive logs
              timestamp: new Date().toISOString()
            };
            handleUploadError(xhr, file, fileId, 'Invalid server response', errorDetails);
          }
        } else {
          // HTTP error status
          let errorMessage = `Server responded with status ${xhr.status}`;
          let errorDetails = {
            httpStatus: xhr.status,
            statusText: xhr.statusText,
            timestamp: new Date().toISOString(),
            chunkIndex: chunkIndex
          };
          
          // Try to parse error details if available
          try {
            if (xhr.responseText) {
              const errorResponse = JSON.parse(xhr.responseText);
              errorDetails = {
                ...errorDetails,
                code: errorResponse.error?.code || errorResponse.code || 'HTTP_ERROR',
                details: errorResponse.error?.message || errorResponse.message || errorResponse.error || 'Unknown server error',
                stack: errorResponse.error?.stack || errorResponse.stack
              };
              errorMessage = errorDetails.details || errorMessage;
            }
          } catch (e) {
            // Unable to parse JSON error
            errorDetails.parseError = e.message;
            errorDetails.rawResponse = xhr.responseText.substring(0, 500); // Limit size
          }
          
          console.error(`HTTP error during upload:`, errorDetails);
          handleUploadError(xhr, file, fileId, errorMessage, errorDetails);
        }
      };
      
      xhr.onerror = function() {
        // Network errors (ECONNRESET, etc.) - a more aggressive retry strategy
        const errorMessage = `Network error on chunk ${chunkIndex + 1}/${totalChunks}. Will retry shortly.`;
        console.error(errorMessage);
        showToast(errorMessage, 'warning');
        
        // Wait a moment before retrying
        setTimeout(() => {
          // Don't increment currentChunk, retry the same one
          const retryJitter = Math.random() * 1000; // Add random delay between 0-1000ms
          uploadChunk(file, fileId);
        }, 2000 + Math.random() * 3000); // Wait 2-5 seconds before retry
      };
      
      xhr.ontimeout = function() {
        const timeoutMessage = `Upload timed out for chunk ${chunkIndex + 1}/${totalChunks}`;
        showToast(timeoutMessage, 'error');
        console.error(timeoutMessage);
        handleUploadError(xhr, file, fileId, timeoutMessage);
      };
      
      // Send the chunk
      xhr.send(formData);
    }
    
    function handleUploadError(xhr, file, fileId, errorMessage, errorDetails = null) {
      console.error(`Upload error: ${errorMessage}`, errorDetails);
      
      if (retryCount < MAX_RETRY_COUNT) {
        // Implement exponential backoff with jitter
        const jitter = Math.random() * 500; // Random jitter between 0-500ms
        const actualDelay = Math.min(retryDelay + jitter, MAX_RETRY_DELAY);
        const retryAttempt = retryCount + 1;
        
        // Show detailed error and retry information
        const retryMessage = `Upload error: ${errorMessage}. 
           Retrying in ${Math.round(actualDelay/1000)} seconds... (Attempt ${retryAttempt}/${MAX_RETRY_COUNT})`;
        
        // Don't show details in the retry notification to avoid overwhelming the user
        showToast(retryMessage, 'warning');
        
        // Update progress info to show retry status
        const infoElement = document.getElementById('uploadInfo');
        if (infoElement) {
          infoElement.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${retryMessage}`;
        }
        
        setTimeout(() => {
          retryCount++;
          retryDelay = Math.min(retryDelay * 2, MAX_RETRY_DELAY); // Exponential backoff
          uploadChunk(file, fileId);
        }, actualDelay);
      } else {
        // Final failure after all retries
        const failMessage = `Upload failed after ${MAX_RETRY_COUNT} attempts: ${errorMessage}`;
        showToast(failMessage, 'error', errorDetails);
        console.error(failMessage, errorDetails);
        
        isUploading = false;
        updateProgress();
        
        // Show a more visible error in the upload info area
        const infoElement = document.getElementById('uploadInfo');
        if (infoElement) {
          infoElement.innerHTML = `<i class="fas fa-times-circle" style="color: var(--warning);"></i> 
            <span style="color: var(--warning);">Upload failed: ${errorMessage}</span>
            <div style="margin-top: 5px; font-size: 12px; color: var(--gray-dark);">
              Check console for details or contact administrator.
            </div>`;
        }
      }
    }

    function updateProgress(uploadedBytes, totalBytes) {
      if (!isUploading) {
        // Reset progress bar when not uploading
        document.querySelector('.progress-bar').style.width = '0%';
        document.getElementById('uploadInfo').textContent = '';
        updateUploadButtonState(false);
        return;
      }
      
      if (!uploadedBytes || !totalBytes) {
        return; // Skip if we don't have valid data
      }
      
      const overallPercent = Math.round((uploadedBytes / totalBytes) * 100);
      
      // Calculate average speed using better weighting of recent speeds
      let avgSpeed = 0;
      if (uploadSpeeds.length > 0) {
        // Weight recent speeds more heavily
        let totalWeight = 0;
        let weightedSum = 0;
        
        for (let i = 0; i < uploadSpeeds.length; i++) {
          // More recent speeds get higher weights
          const weight = Math.pow(1.5, i);
          weightedSum += uploadSpeeds[i] * weight;
          totalWeight += weight;
        }
        
        avgSpeed = weightedSum / totalWeight;
      }
      
      // Calculate ETA based on recent speed and remaining bytes
      const remainingBytes = totalBytes - uploadedBytes;
      let estimatedTimeRemaining = 0;
      
      if (avgSpeed > 0) {
        estimatedTimeRemaining = remainingBytes / avgSpeed;
      } else {
        // Fallback to average speed since start
        const elapsedTime = (Date.now() - overallStartTime) / 1000;
        if (elapsedTime > 0 && uploadedBytes > 0) {
          const overallSpeed = uploadedBytes / elapsedTime;
          estimatedTimeRemaining = remainingBytes / overallSpeed;
        }
      }
      
      // Format values for display
      const speedText = formatSize(avgSpeed) + '/s';
      const remainingText = formatSize(remainingBytes);
      const etaText = formatTime(estimatedTimeRemaining);
      const chunkText = `Chunk ${currentChunk + 1}/${totalChunks}`;
      
      // Only update UI if not throttled or once every second if throttled
      const now = Date.now();
      if (!isThrottled || (now - lastUIUpdate > 1000)) {
        document.querySelector('.progress-bar').style.width = overallPercent + '%';
        document.getElementById('uploadInfo').innerHTML = 
          `<i class="fas fa-info-circle"></i> ${overallPercent}% complete â€¢ ${chunkText} â€¢ ${speedText} â€¢ ${remainingText} remaining â€¢ ETA: ${etaText}`;
        
        lastUIUpdate = now;
      }
    }

    function formatSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    function formatTime(seconds) {
      if (!isFinite(seconds) || seconds === 0) return 'calculating...';
      
      if (seconds < 60) return Math.round(seconds) + ' sec';
      if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        const sec = Math.round(seconds % 60);
        return `${minutes} min ${sec} sec`;
      }
      
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return `${hours} hr ${minutes} min`;
    }

    function showHowTo() {
      const modal = document.getElementById('howToModal');
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden'; // Prevent scrolling behind modal
    }

    function closeHowTo() {
      document.getElementById('howToModal').style.display = 'none';
      document.body.style.overflow = ''; // Restore scrolling
    }

    function showToast(message, type = '', details = null, duration = 5000) {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toastMessage');
      const errorDetails = document.getElementById('errorDetails');
      const toastActions = document.getElementById('toastActions');
      const icon = toast.querySelector('i');
      
      // Clear previous content
      toastMessage.textContent = message;
      errorDetails.textContent = '';
      errorDetails.className = '';
      toastActions.innerHTML = '';
      
      // Update icon based on message type
      if (type === 'success') {
        icon.className = 'fas fa-check-circle';
      } else if (type === 'error') {
        icon.className = 'fas fa-times-circle';
      } else if (type === 'info') {
        icon.className = 'fas fa-info-circle';
      } else if (type === 'warning') {
        icon.className = 'fas fa-exclamation-triangle';
      } else {
        icon.className = 'fas fa-bell';
      }
      
      // Set class for styling
      toast.className = type ? `show ${type}` : 'show';
      
      // For longer messages, ensure enough time to read
      const minDuration = Math.max(2000, message.length * 50);
      let actualDuration = Math.max(duration, minDuration);
      
      // Add error details if provided
      if (details && type === 'error') {
        errorDetails.textContent = typeof details === 'object' ? 
          JSON.stringify(details, null, 2) : details.toString();
        errorDetails.className = 'has-details';
        toast.className += ' detailed';
        
        // Add copy button for error details
        const copyButton = document.createElement('button');
        copyButton.innerHTML = '<i class="fas fa-copy"></i> Copy Error';
        copyButton.onclick = function() {
          navigator.clipboard.writeText(
            `Error: ${message}\nDetails: ${errorDetails.textContent}`
          ).then(() => {
            copyButton.innerHTML = '<i class="fas fa-check"></i> Copied!';
            setTimeout(() => {
              copyButton.innerHTML = '<i class="fas fa-copy"></i> Copy Error';
            }, 2000);
          });
        };
        toastActions.appendChild(copyButton);
        
        // Longer duration for errors with details
        actualDuration = Math.max(actualDuration, 15000);
      }
      
      // Hide after duration
      setTimeout(function(){ 
        toast.className = toast.className.replace("show", ""); 
      }, actualDuration);
    }

    // Event listeners
    window.onclick = function(event) {
      const modal = document.getElementById('howToModal');
      if (event.target === modal) {
        closeHowTo();
      }
    }

    // Support for drag & drop
    const dropArea = document.querySelector('.file-input-container');
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, unhighlight, false);
    });
    
    function highlight() {
      dropArea.querySelector('.file-input-button').style.borderColor = 'var(--primary)';
      dropArea.querySelector('.file-input-button').style.backgroundColor = 'rgba(67, 97, 238, 0.05)';
    }
    
    function unhighlight() {
      dropArea.querySelector('.file-input-button').style.borderColor = 'var(--gray-dark)';
      dropArea.querySelector('.file-input-button').style.backgroundColor = 'var(--gray-light)';
    }
    
    dropArea.addEventListener('drop', handleDrop, false);
    
    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      document.getElementById('fileInput').files = files;
      updateFileInfo();
    }

    // Show how-to guide on first visit
    window.onload = () => {
      fetchFolders('/');
      
      // Check for unfinished uploads
      setTimeout(() => {
        checkForUnfinishedUploads();
      }, 1000); // Check after 1 second to avoid delaying initial page load
    };

    function cancelUpload() {
      if (isUploading) {
        chunkUploadAborted = true;
        showToast('Upload cancelled.', 'info');
        isUploading = false;
        updateProgress();
      }
    }

    // Add upload resumption support
    function checkForUnfinishedUploads() {
      try {
        const lastUploadTime = localStorage.getItem('lastUploadTime');
        const fileId = localStorage.getItem('lastUploadFileId');
        const fileName = localStorage.getItem('lastUploadFileName');
        const lastChunkIndex = localStorage.getItem('lastChunkIndex');
        const totalChunks = localStorage.getItem('totalChunks');
        
        // Check if we have all the required data and if it's recent (less than 24 hours old)
        if (lastUploadTime && fileId && fileName && lastChunkIndex && totalChunks) {
          const timeElapsed = Date.now() - parseInt(lastUploadTime);
          const hoursElapsed = timeElapsed / (1000 * 60 * 60);
          
          if (hoursElapsed < 24) {
            // Show resume option
            showResumeUploadDialog(fileName, parseInt(lastChunkIndex), parseInt(totalChunks), fileId);
          } else {
            // Clear old data
            clearUnfinishedUploadData();
          }
        }
      } catch (error) {
        console.warn('Error checking for unfinished uploads:', error);
      }
    }
    
    function showResumeUploadDialog(fileName, lastChunkIndex, totalChunks, fileId) {
      // Calculate progress percentage
      const progress = Math.round((lastChunkIndex / totalChunks) * 100);
      
      // Show toast with resume option
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toastMessage');
      const icon = toast.querySelector('i');
      
      icon.className = 'fas fa-exclamation-circle';
      toast.className = toast.className.replace("show", "");
      
      // Create resume button inside toast
      toastMessage.innerHTML = `<div>Unfinished upload found: ${fileName} (${progress}% complete)</div>
        <button id="resumeButton" style="margin-top: 10px; padding: 5px 10px; background: white; color: var(--primary); border: none; border-radius: 4px; cursor: pointer;">
          <i class="fas fa-play-circle"></i> Resume Upload
        </button>
        <button id="discardButton" style="margin-top: 10px; margin-left: 10px; padding: 5px 10px; background: rgba(255,255,255,0.3); color: white; border: none; border-radius: 4px; cursor: pointer;">
          <i class="fas fa-times-circle"></i> Discard
        </button>`;
      
      // Keep toast open longer
      setTimeout(function() {
        if (toast.className.includes('show')) {
          toast.className = toast.className.replace("show", "");
        }
      }, 15000); // 15 seconds
      
      // Add event listeners
      document.getElementById('resumeButton').addEventListener('click', function() {
        toast.className = toast.className.replace("show", "");
        promptForFileToResume(fileName, lastChunkIndex, totalChunks, fileId);
      });
      
      document.getElementById('discardButton').addEventListener('click', function() {
        toast.className = toast.className.replace("show", "");
        clearUnfinishedUploadData();
      });
    }
    
    function promptForFileToResume(fileName, lastChunkIndex, totalChunks, fileId) {
      // Create a temporary file input to select the same file again
      const input = document.createElement('input');
      input.type = 'file';
      input.style.display = 'none';
      document.body.appendChild(input);
      
      input.onchange = function() {
        if (input.files.length > 0) {
          const file = input.files[0];
          
          // Check if it's the same file by name and size (approximate check)
          if (file.name === fileName) {
            // Set the file in our main input
            document.getElementById('fileInput').files = input.files;
            updateFileInfo();
            
            // Resume upload from last chunk
            resumeUpload(file, lastChunkIndex, totalChunks, fileId);
          } else {
            showToast(`Selected file "${file.name}" doesn't match the unfinished upload "${fileName}"`, 'error');
          }
        }
        
        // Remove temporary input
        document.body.removeChild(input);
      };
      
      // Trigger file selection
      input.click();
    }
    
    function resumeUpload(file, lastChunkIndex, totalChunks, fileId) {
      // Calculate optimal chunk size based on file size
      let optimalChunkSize = 5 * 1024 * 1024; // Default 5MB
      if (file.size < 10 * 1024 * 1024) { // Less than 10MB
        optimalChunkSize = 1 * 1024 * 1024; // Use 1MB chunks
      } else if (file.size > 1024 * 1024 * 1024) { // More than 1GB
        optimalChunkSize = 10 * 1024 * 1024; // Use 10MB chunks
      }
      
      // Reset state
      currentChunk = parseInt(lastChunkIndex);
      totalChunks = parseInt(totalChunks);
      chunkUploadAborted = false;
      isUploading = true;
      isThrottled = document.hidden;
      lastProgressTime = 0;
      lastChunkBytes = 0;
      retryCount = 0;
      retryDelay = 1000;
      uploadSpeeds = [];
      
      // Show upload in progress
      updateUploadButtonState(true);
      
      // Initialize progress display
      document.querySelector('.progress-container').style.display = 'block';
      document.querySelector('.progress-bar').style.width = `${Math.round((currentChunk / totalChunks) * 100)}%`;
      document.getElementById('uploadInfo').innerHTML = 
        `<i class="fas fa-info-circle"></i> Resuming upload from ${Math.round((currentChunk / totalChunks) * 100)}%...`;
      
      showToast(`Resuming upload of ${file.name} from ${Math.round((currentChunk / totalChunks) * 100)}%...`, 'info');
      
      // Resume upload
      uploadChunk(file, fileId);
    }
    
    function clearUnfinishedUploadData() {
      try {
        localStorage.removeItem('lastUploadFileId');
        localStorage.removeItem('lastUploadFileName');
        localStorage.removeItem('lastUploadTime');
        localStorage.removeItem('lastChunkIndex');
        localStorage.removeItem('totalChunks');
      } catch (error) {
        console.warn('Error clearing unfinished upload data:', error);
      }
    }
  </script>
</body>
</html>
